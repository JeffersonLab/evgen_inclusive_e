====Introduction ========================

An inclusive electron generator
The process includes QE + resonance + DIS for nucleus target with Z protons and A atoms.
The W<3 GeV region uses Peter Bosted fit
the W>3 GeV region uses world PDF sets, the LHAPDF6 interface is used
refer to http://hallaweb.jlab.org/12GeV/SoLID/download/sim/talk/Inclusive_electron_generator.pdf

Please send questions Zhiwen Zhao (zwzhao@jlab.org), Ye Tian (tainye@jlab.org)

==== log =================================
2021/01/01 commit "6f26734"
adding unpolarized radiative correction and input file by David Flay and Ye Tian, output adjustment by Zhiwen Zhao

2020/04/24 commit "4b22e1b"
convert to github by Zhiwen Zhao from https://jlabsvn.jlab.org/svnroot/solid/evgen/solid_inclusive_e

2017/02/13 
written and tested with LHAPDF6.1.6 by Yuxiang Zhao (yxzhao@jlab.org)

====install========================
It requires ROOT5.34.36 and LHAPDF6.1.6 with pdfsets of NNPDFpol11_100 and CT14nlo at least
(see how to install LHAPDF6.1.6 below)

The current setup file has default ROOT and LHAPDF6 path on ifarm
You need to put your ROOT and LHAPDF6 path if compiling on other machine

>source setup
>cmake .
>make

==== run it and understand output ====

> source setup
>./evgen_inclusive_e inputfile

see inputfile example under input dir
rad: 0 Born cross section only; 1:unpolarized radiative cross section with smearing; 2:unpolarized radiative cross section without smearing
(radiative code is slow about 0.15s/event)

a rootfile and a txt file in lund format will be produced in the current directory

compare_eDIS_eAll.C is used to compare output root files between 
"eDIS" from https://github.com/JeffersonLab/evgen_inclusive
"eAll" from https://github.com/JeffersonLab/evgen_inclusive_e 

==== code details ==================
pure C/C++ code, using CMake compiler

The main code "evgen_inclusive_e.C" is segmented into several regions:
1. user inputs for the simulation -> define the simulation parameters
2. load polpodf and unpolpdfs for W>3 GeV region ->user doesn't need to deal with it normally
3. Define outputs, lund output and tree definition  -> user can modify it according to the needs
4. throw events and calculate rate, kinematics etc. for each event using the functions provided
by the package   -->user can modify it according to the needs

All the functions are shown in the include directory, here is also a list of functions
that can be used by users:

#############################################################################################
double calculate_neutron_g1gz(PDF* pol_pdf, double x, double Q2);

double calculate_neutron_g5gz(PDF* pol_pdf, double x, double Q2);

double calculate_neutron_F2g(PDF* unpol_pdf, double x, double Q2);

double calculate_neutron_F1g(PDF* unpol_pdf, double x, double Q2);

double calculate_neutron_F1gz(PDF* unpol_pdf, double x, double Q2);

double calculate_neutron_F3gz(PDF* unpol_pdf, double x, double Q2);

//---PVDIS asymmetries

double calculate_neutron_Abeam(PDF* unpol_pdf, double x, double Q2, double y);

double calculate_neutron_AL(PDF* unpol_pdf, PDF* pol_pdf, double x, double Q2, double y);

double calculate_neutron_AL_g1gz(PDF* unpol_pdf, PDF* pol_pdf, double x, double Q2, double y);

double calculate_neutron_AL_g5gz(PDF* unpol_pdf, PDF* pol_pdf, double x, double Q2, double y);

//proton structure functions
double calculate_proton_g1gz(PDF* pol_pdf, double x, double Q2);

double calculate_proton_g5gz(PDF* pol_pdf, double x, double Q2);

double calculate_proton_g3gz(PDF* pol_pdf, double x, double Q2);

double calculate_proton_g5z(PDF* pol_pdf, double x, double Q2);

double calculate_proton_g3z(PDF* pol_pdf, double x, double Q2);

double calculate_proton_F2g(PDF* unpol_pdf, double x, double Q2);

double calculate_proton_F1g(PDF* unpol_pdf, double x, double Q2);

double calculate_proton_F1gz(PDF* unpol_pdf, double x, double Q2);

double calculate_proton_F3gz(PDF* unpol_pdf, double x, double Q2);

//---proton asymmetries
//---PVDIS asymmetry using unpol electron + longitudinally polarized proton
double calculate_proton_AL(PDF* unpol_pdf, PDF* pol_pdf, double x, double Q2, double y);

double calculate_proton_AL_g1gz(PDF* unpol_pdf, PDF* pol_pdf, double x, double Q2, double y);

double calculate_proton_AL_g5gz(PDF* unpol_pdf, PDF* pol_pdf, double x, double Q2, double y);

//---PVDIS asymmetry using long. pol. electron + unpolarized proton
double calculate_proton_Abeam(PDF* unpol_pdf, double x, double Q2, double y);

double calculate_fixed_target_xs(double E, int Z, int A, double theta, double Ep, PDF* unpol_pdf);

//Peter Bosted model
int F1F2IN09(int Z, int IA, double qsq, double wsq, double &F1, double &F2, double &Rc);

// Peter Bosted model
void F1F2QE09(int Z, int IA, double QSQ, double wsq, double &F1, double &F2);
#############################################################################################

*** How to install LHAPDF6:******
refer to https://lhapdf.hepforge.org/install.html
for 6.1.6
> make sure boost packages are installed by checking "rpm -qa |grep boost"
> mkdir -p LHAPDF/source
> cd LHAPDF/source
> wget http://www.hepforge.org/archive/lhapdf/LHAPDF-6.1.6.tar.gz
> tar xf LHAPDF-6.1.6.tar.gz
> cd LHAPDF-6.1.6
> ./configure --prefix=$PWD/../../LHAPDF-6.1.6
> make
> make install
> cd ../../LHAPDF-6.1.6/share/LHAPDF/
> wget http://www.hepforge.org/archive/lhapdf/pdfsets/v6.backup/6.1.6/NNPDFpol11_100.tar.gz
> tar zxf NNPDFpol11_100.tar.gz
> wget http://www.hepforge.org/archive/lhapdf/pdfsets/v6.backup/6.1.6/CT14nlo.tar.gz
> tar zxf CT14nlo.tar.gz
> wget http://www.hepforge.org/archive/lhapdf/pdfsets/v6.backup/6.1.6/CT14lo.tar.gz
> tar zxf CT14lo.tar.gz
> wget http://www.hepforge.org/archive/lhapdf/pdfsets/v6.backup/6.1.6/cteq66.tar.gz
> tar zxf cteq66.tar.gz
